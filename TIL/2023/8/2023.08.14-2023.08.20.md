# 2023.08.14
# 동시성
> `공유 자원`에 대해 `동시에 여러 개의 프로세스 또는 쓰레드가 접근`하여 생기는 `경쟁 상황(Race Condition)`을 동시성 문제라고 합니다.

## 동기화(Synchronization)
여러 프로세스/스레드를 동시에 실행해도 `공유 데이터의 일관성`을 유지하는 것

## Race Condition(경쟁 조건)
`두 개 이상의 프로세스 혹은 스레드`가 공유 자원을 서로 사용하려고 `경합(Race)`하는 현상을 의미합니다.

## Critical Section(임계 영역)
공유 데이터의 `일관성을 보장하기 위해` `하나의 프로스세/스레드만 진입`해서 실행 가능한 영역

## 프로세스
CPU(프로세서)에 의해 실행되고 있는 프로그램이며 최소 1 개의 스레드가 존재합니다.   
JVM이 실행되어 컴파일러에 의해 변환된 바이트코드가 메모리 상에 올라갔을 때 "프로세스가 실행 중이다"라고 합니다.

### 멀티 프로세싱
두 개 이상의 프로세서(CPU)가 하나 이상의 작업(Task)을 동시에 처리하는 것입니다.(병렬처리)
프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업 속도가 느려질 수는 있지만 정지되는 문제는 발생하지 않습니다. (ex. 크롬 브라우저)

## 스레드
스레드는 프로스세 내에서 실행되는 작업 흐름의 단위입니다.   
메모리 영역(Code, Data, Heap)을 공유하기 때문에 메모리가 효율적이고, 같은 프로세스에 있는 스레들끼리 컨텍스트 스위칭 비용이 적으며 통신 비용도 절감됩니다.

### 멀티 스레드
하나의 프로세스가 동시에 여러 개의 스레드를 수행할 수 있도록 해주는 것입니다.   
스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받습니다. (ex. 익스플로러 브라우저)

## Lock
### Exclusive Lock(배타적 잠금)
- `쓰기 잠금(Write Lock)`
- 어떤 트랜잭션에서 데이터를 변경하고자 할 때 해당 트랜잭션이 완료될 때까지 해당 테이블 혹은 레코드(row)에 다른 트랜잭션에서 읽거나 쓰지 못하게 락을 걸고 트랜잭션을 진행시키는 것입니다.

### Shared Lock(공유 잠금)
- `읽기 잠금(Read Lock)`
- 리소스를 다른 사용자가 동시에 읽을 수 있게 하되 변경은 불가하게 하는 것입니다.
- Shared Lock을 사용하는 쿼리끼리는 같은 Row에 접근이 가능합니다.

</br>

# 동시성 이슈 해결 방법 (동시성 제어 방식)
## 1. Application 레벨에서 해결하는 방법
### 1. synchronized 키워드

### 2. volatile 키워드

### 3. Atomic 클래스

## 2. Mysql을 활용하는 방법 (Database Lock)
### 1. Pessimistic Lock(비관적 락)
- `실제로 데이터에 Lock을 걸어서 정합성`을 맞추는 방법
- Exclusive Lock(배타적 잠금)을 걸게되면 다른 트랜잭션에서는 Lock이 해제되기 전에 데이터를 가져갈 수 없게 됩니다.
- 데드락이 걸릴 수 있기 때문에 주의하여 사용하여야 합니다.
- 뮤텍스, 세마포어

<img width="936" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/448aea2e-1fd9-4118-a9b2-204ea53d9ece">   

- Server 1이 락을 걸고 데이터를 가져가게 되면 Server 2 ~ 5는 Server 1이 락을 해제 하기전까지는 데이터를 가져갈 수 없습니다.

### 2. Optimistic Lock(낙관적 락)
- 실제로 Lock을 이용하지 않고 `버전을 이용함으로써 정합성`을 맞추는 방법입니다.
- 먼저 데이터를 읽은 후에 update를 수행할 때 현재 내가 읽은 버젼이 맞는지 확인하며 업데이트 합니다.
- 내가 읽은 버전에서 수정사항이 생겼을 경우에는 application에서 다시 읽은 후에 작업을 수행해야 합니다.

<img width="857" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/108b1e05-e689-4144-9ebd-0b544068ad66">

  1. Sever 1이 update 하면서 `version 2로 업데이트` 함
  2. 1번 과정 이후에 Server 2가 동일한 update 쿼리를 수행하려할 때 `where의 version = 1` 이 false 이기 때문에 update 실패
  3. `내가 읽은 버전에서 수정사항이 생겼을 경우`에는 `application에서 다시 읽은 후에 작업을 수행해야 하는 로직`을 넣어줘야 합니다.

### 3. Named Lock(네임드 락)
- 이름을 가진 `Metadata Locking` 입니다.
- 이름을 가진 Lock을 획득한 후 해제할 때까지 다른 세션은 이 Lock을 획득할 수 없도록 합니다.
- 주의할점으로는 `Transaction이 종료될 때 Lock이 자동으로 해제되지 않기 때문에` `별도의 명령어로 해제를 수행해주거나 선점시간이 끝나야 해제`됩니다.
- Pessimistic Lock(비관적 락)과 유사한데 차이점은 `Pessimistic Lock(비관적 락)은 row 나 테이블 단위로 Lock`을 걸지만 `Named Lock(네임드 락)은 Metadata에 Locking`을 하는 방식입니다.

> 참고   
> - https://dev.mysql.com/doc/refman/8.0/en/
> - https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html
> - https://dev.mysql.com/doc/refman/8.0/en/metadata-locking.html


## 3. Redis를 활용하여 분산락을 구현하는 방법 (대표적인 라이브러리 2가지)
### 1. Lettuce
- **`setnx`** 명령어를 활용하여 분산락 구현: key와 value를 set 할 때, **기존에 값이 없을 때만 set 하는 방법**
- **`spin lock 방식`**: 락을 획득하려는 스레드가 락을 사용할 수 있는지 반복적으로 확인하면서 락 획득을 시도하는 방식, 락을 획득할 때까지 재시도하는 로직을 작성 해줘야 합니다.
- Mysql의 Named Lock과 거의 비슷한데 다른점으로는 Redis를 이용한다는 점과 세션 관리에 신경을 안써도 된다는 점입니다.

<img width="1008" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/9e29b65d-3276-4cf3-bb29-d6d39135e07e">

### 2. Redisson
- **`pub-sub`** 기반으로 Lock 구현: 채널을 하나 만들고 락을 점유중인 스레드가 락을 획득하려고 대기중인 스레드에게 해제를 알려주면 안내를 받은 스레드가 락 획득 시도를 하는 방식, 대부분의 경우에 Lettuce와는 다르게 별도의 Retry 로직을 작성하지 않아도 됩니다.
- Redisson은 락 관련 클래스들을 라이브러리에서 제공해주므로 별도의 Repository를 작성하지 않아도 됩니다.

<img width="1839" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/a45c5ca3-8532-40ce-892e-c2c3f04cb969">

### [코드]
<img width="707" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/
5f03af81-6d6f-4568-9c6b-dc4ff4e668f5">

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-redis'
}
```
> redisson은 별도의 라이브러리가 필요하므로 의존성을 추가해줍니다.

## Lettuce와 Redisson 라이브러리 비교
### Lecttuce
    - 장점: 
        1. 구현이 간단하다.
        2. Spring Data Redis를 이용하면 Lettuce가 기본이기 때문에 별도의 라이브러리를 사용하지 않아도 된다.
    - 단점: 
        1. Spin Lock 방식이기 때문에 동시에 많은 스레드가 lock 획득 대기 상태라면 Redis에 부하가 갈 수 있다. 그렇기 때문에 Thread.sleep()을 통해 락 획득 재시도 간에 텀을 줘야한다.

### Redisson
    - 장점: 
        1. 락 획득 재시도를 기본으로 제공한다.
        2. pub-sub 방식이기 때문에 Lettuce와 비교했을 때 Redis에 부하가 덜 간다.
    - 단점:
        1. Spring Data Redis의 기본 라이브러리는 Rettuce이기 때문에 별도의 라이브러리를 사용해야하고, lock을 라이브러리 차원에서 제공해주기 때문에 사용법을 공부해야 한다.

### 결론
> 재시도가 필요하지 않은 Lock은 **`Lettuce`** 활용   
> 재시도가 필요한 경우에는 **`Reddisson`** 을 활용

## Mysql과 Redis 비교
### Mysql
    - 장점: 
        1. 이미 Mysql을 사용하고 있다면 별도의 비용없이 사용 가능하다.
        2. 어느 정도의 트래픽까지는 문제없이 활용이 가능하다.
    - 단점:
        1. Redis 보다는 성능이 좋지 않다.

### Redis
    - 장점: 
        1. Mysql 보다 성능이 좋다.
    - 단점:
        1. 활용중인 Redis가 없다면 별도의 구축비용과 인프라 관리비용이 발생한다.

### 동시성 제어 시 어떤 방법을 채택해야 할까?
> 일반적으로 레디스는 **`인메모리 데이터베이스이기 때문에 높은 처리량과 낮은 지연 시간`** 을 제공합니다. 따라서 **`많은 동시 요청을 처리해야 하는 시스템이라면`**, 레디스를 사용하여 동시성 제어를 하는 것이 더 효율적일 수 있습니다.   
> 
> 반면에 DB 락은 데이터의 **`consistency(일관성)`** 를 보장하면서 동시에 데이터 접근을 제어할 수 있는 방법입니다. DB 락은 일반적으로 트랜잭션이나 레코드 레벨에서 사용되며, **`데이터베이스에서 처리해야 할 복잡한 로직`** 이 있는 경우에 적합합니다.
> 
> 따라서, 동시성 제어 방법은 시스템의 특성과 요구사항에 따라 다르게 결정되어야 하며, 단순한 상황에 따라 “레디스를 사용하는 것이 제일 좋은 방법”이거나 “DB 락을 사용하는 것이 더 좋은 경우”로 일반화할 수는 없습니다.   
동시성 제어 방법을 결정할 때는 시스템의 특성, 처리량, 지연 시간 요구사항, 데이터 일관성 등을 고려하여 적절한 방법을 선택해야 합니다.

## 동기화 처리 기법 (락 매카니즘)
### 1. 스핀 락(Spin Lock)
락을 가질 수 있을 때 까지 `반복해서 시도`   
단점: 기다리는 동안 CPU를 낭비

### 2. 뮤텍스(Mutex)
락을 가질 수 있을 때 까지 `휴식`

### 3. 세마포어(Semaphore)
Signal Mechanism을 가진 하나 이상의 프로세스/스레드가 Critical Section에 접근 가능하도록 하는 장치
 - 예) 공중화장실에 좌변기가 3개가 있을 때, 3개까지는 동시에 사용할 수 있는데 이럴 때 세마포어를 사용할 수 있습니다.
  
### 4. 모니터(Monitor)
Mutual Exclusion(상호배제)을 보장, 조건에 따라 스레드가 대기(Wating) 상태로 전환 기능
뮤텍스와 세마포어를 추상화한 개념

### 그럼 뮤텍스가 스핀락보다 항상 좋은걸까?
`멀티코어` 환경이고, **`Critical Section(임계 영역)`에서의 작업이 `컨텍스트 스위칭`보다 더 빨리 끝난다면** `스핀락`이 `뮤텍스`보다 더 이점이 있습니다.   
- 여기서 말하는 컨텍스트 스위칭은 뮤텍스에서 락을 가질 수 있을 때 까지 `휴식`하다가 깨는 과정입니다.   
- 싱글 코어에서는 결국 컨텍스트 스위칭이 필요하기 때문에 스핀락의 이점이 전혀 없습니다.




