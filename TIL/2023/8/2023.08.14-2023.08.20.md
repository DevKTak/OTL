# 2023.08.14
# 동시성
> 공유 자원에 대해 동시에 여러 개의 프로세스가 접근하여 생기는 경쟁 상황(Race Condition)을 동시성 문제라고 합니다.

## 프로세스
CPU(프로세서)에 의해 실행되고 있는 프로그램이며 최소 1 개의 스레드가 존재합니다.   
JVM이 실행되어 컴파일러에 의해 변환된 바이트코드가 메모리 상에 올라갔을 때 "프로세스가 실행 중이다"라고 합니다.

### 멀티 프로세싱
두 개 이상의 프로세서(CPU)가 하나 이상의 작업(Task)을 동시에 처리하는 것입니다.(병렬처리)
프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업 속도가 느려질 수는 있지만 정지되는 문제는 발생하지 않습니다. (ex. 크롬 브라우저)

## 스레드
스레드는 프로스세 내에서 실행되는 작업 흐름의 단위입니다.   
메모리 영역(Code, Data, Heap)을 공유하기 때문에 메모리가 효율적이고, 같은 프로세스에 있는 스레들끼리 컨텍스트 스위칭 비용이 적으며 통신 비용도 절감됩니다.

## 멀티 스레드
하나의 프로세스가 동시에 여러 개의 스레드를 수행할 수 있도록 해주는 것입니다.   
스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받습니다. (ex. 익스플로러 브라우저)

## 동시성 이슈 해결 방법
## 1. Java에서 해결하는 방법
### synchronized 키워드

### volatile 키워드

### Atomic 클래스


## 2. DB에서 해결하는 방법
### DB Lock
#### Exclusive Lock(배타적 잠금)
- 쓰기 잠금(Write Lock)
- 어떤 트랜잭션에서 데이터를 변경하고자 할 때 해당 트랜잭션이 완료될 때까지 해당 테이블 혹은 레코드(row)에 다른 트랜잭션에서 읽거나 쓰지 못하게 락을 걸고 트랜잭션을 진행시키는 것입니다.

#### Shared Lock(공유 잠금)
- 읽기 잠금(Read Lock)
- 리소스를 다른 사용자가 동시에 읽을 수 있게 하되 변경은 불가하게 하는 것입니다.
- Shared Lock을 사용하는 쿼리끼리는 같은 Row에 접근이 가능합니다.

## 2-1. Mysql을 활용하는 방법
### 1. Pessimistic Lock(비관적 락)

### 2. Optimistic Lock(낙관적 락)

### 3. Named Lock(네임드 락)

## 2-2. Redis를 활용하여 분산락을 구현하는 방법 (대표적인 라이브러리 2가지)
### 1. Lettuce
- setnx 명령어를 활용하여 분산락 구현: key와 value를 set 할 때, 기존에 값이 없을 때만 set 하는 방법
- spin lock 방식: 락을 획득하려는 스레드가 락을 사용할 수 있는지 반복적으로 확인하면서 락 획득을 시도하는 방식, 락을 획득할 때까지 재시도하는 로직을 작성 해줘야 합니다.
- Mysql의 Named Lock과 거의 비슷한데 다른점으로는 Redis를 이용한다는 점과 세션 관리에 신경을 안써도 된다는 점입니다.
- 구현이 간단하다는 장점이 있지만 Spin Lock 방식이므로 Redis에 부하를 줄 수 있습니다. 그렇기때문에 Thread.sleep()을 통해 락 획득 재시도 간에 텀을 줘야합니다.

<img width="1008" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/9e29b65d-3276-4cf3-bb29-d6d39135e07e">

### 2. Redisson
- pub-sub 기반으로 Lock 구현: 채널을 하나 만들고 락을 점유중인 스레드가 락을 획득하려고 대기중인 스레드에게 해제를 알려주면 안내를 받은 스레드가 락 획득 시도를 하는 방식, 대부분의 경우에 Lettuce와는 다르게 별도의 Retry 로직을 작성하지 않아도 됩니다.

<img width="1839" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/a45c5ca3-8532-40ce-892e-c2c3f04cb969">

### [코드]
<img width="707" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/
5f03af81-6d6f-4568-9c6b-dc4ff4e668f5">

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-redis'
}
```
> redisson은 Lettuce와 달리 


---

## 동기화 처리 기법
### 1. 스핀락(Spinlock)

### 2. 뮤텍스(Mutex)

### 3. 세마포어(Semaphore)

### 4. 모니터(Monitor)

## 동시성 제어 시 어떤 방법을 채택해야 할까?
일반적으로 레디스는 인메모리 데이터베이스이기 때문에 높은 처리량과 낮은 지연 시간을 제공합니다. 따라서 많은 동시 요청을 처리해야 하는 시스템이라면, 레디스를 사용하여 동시성 제어를 하는 것이 더 효율적일 수 있습니다.

반면에 DB 락은 데이터의 consistency를 보장하면서 동시에 데이터 접근을 제어할 수 있는 방법입니다. DB 락은 일반적으로 트랜잭션이나 레코드 레벨에서 사용되며, 데이터베이스에서 처리해야 할 복잡한 로직이 있는 경우에 적합합니다.

따라서, 동시성 제어 방법은 시스템의 특성과 요구사항에 따라 다르게 결정되어야 하며, 단순한 상황에 따라 “레디스를 사용하는 것이 제일 좋은 방법”이거나 “DB 락을 사용하는 것이 더 좋은 경우”로 일반화할 수는 없습니다.

동시성 제어 방법을 결정할 때는 시스템의 특성, 처리량, 지연 시간 요구사항, 데이터 일관성 등을 고려하여 적절한 방법을 선택해야 합니다.