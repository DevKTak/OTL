# 네트워크
> **Q. 개발자로서 DNS를 구현한다면 어떤 자료구조를 선택하고 어떤 프로토콜을 선택할 것 같은지?**  
> A. **Map**

> **Q. 맵으로 자료구조를 선택하였을 때 유저의 DNS 쿼리가 들어온다면 처리하느데 소요되는 시간 복잡도는?**  
> A. **최선의 경우 O(1)** 이고 **해시충돌이 일어날 경우 O(N)**

> **Q. 그럼 해시 충돌은 왜 일어날까요?**  
> A. 먼저 **해시 함수란** 임의의 길이를 갖는 메시지를 입력받아 고정된 길이의 해시값을 출력하는 함수  
> **해시테이블**은 해시함수(key값을 mod 연산)를 사용해서 나온 해시값을 key값으로 하고 데이터를 Value로 하여 테이블 형태로 만든다.여기서 해시값을 key값으로 해시 테이블에 insert 하려고 보니까 이미 데이터가 있는 경우를 **해시충돌** 이라고 한다.

> **Q. 그렇다면 충돌을 해결하기 위한 알고리즘은?**  
> A. **Open Addressing:** 다음 버킷이 비어있는지 하나씩 순차적으로 증가하면서 빈 버킷을 찾는 행위  
> **Chaining:** 보통은 이 방식으로 해결을 많이 하며, 해당 버킷(노드)에 chaining 형태로 계속 뒤로 붙인다.

> **Q. 공간 복잡도 측면에서는 어떻게 될까요?**  
> A. 시간 복잡도와 반대로 최소의 경우 O(N): 모든 객체에 대해서 다 다른 값을 리턴하는 경우, 최대의 경우 O(1): 해시 함수가 모두 같은 값을 리턴하는 경우

> **Q. DNS를 조회하는데 TCP와 UDP 중에 어떤것을 사용할 것 같은지?**  
> A. 기본적으로는 UDP를 사용할 것 같습니다. DNS 쿼리와 응답은 대부분 작은 크기의 패킷으로 전성되기 때문에, UDP의 높은 전송속도와 적은 오버헤드가 유리합니다. 또한, UDP는 연결 지향적이지 않기 때문에 연결 설정 및 해제 과정이 필요하지 않아서 빠르고 경량화된 구현이 가능합니다.  
> 하지만, 대규모 트래픽이 발생하거나 보안강화가 필요한 경우에는 TCP를 고려할 수 있습니다.  
> TCP는 연결 지향적이고, 데이터 전송 과정에서 오류가 발생할 경우 재전송을 통해 데이터 무결성을 유지할 수 있기 때문입니다.  
>   
> \+ TCP는 3 Way Handshake 비용이 너무 크다  
> \* MTU(Maximum Transmission Unit): 데이터링크에서 패킷에 담아 운반 가능한 최대 크기

> **Q. 4 Way Handshake란?**  
> A. TCP/IP 네트워크 환경에서 서버와 클라이언트 연결을 해제(세션 종료)하는데 필요한 프로세스입니다.  
> 1\. 클라이언트가 연결 종료 요청 패킷(FIN)을 보냅니다.  
> 2\. 서버는 FIN을 받고 데이터 전송을 모두 마쳤다면 ACK를 보냅니다.  
> 3\. 서버가 보낸 데이터를 모두 수신한 것을 확인한 후, 이번엔 서버가 연결 종료 요청 패킷(FIN)을 보냅니다.  
> 4\. 클라이언트가 응답(ACK)를 보냅니다.

> **Q. 로드 밸런서를 통해서 유저는 1, 2, 3번 서버 중에 임의의 서버에 접속을 한 상황입니다. 그리고 로드 밸런서의 라우팅 규칙에 따라서 접속한 서버는 서로가 어떤 정보를 세션에 저장했는지 공유하지 않습니다. 이 상황에서 로드 밸런서를 사용해서 이 세션 처리를 해주려고 한다면 어떤 솔루션을 제시할 것 같으신가요? (별도의 세션 서버를 두는 방식인 클러스터링 또는 글로벌세션 제외)**  
> A. Sticky session(세션을 사용하여 트래픽을 분산하는 것이다.)을 사용합니다.  
> 세션도 결국 HTTP 헤더의 한 필드이기에 로드 밸런서가 OSI 7계층인 애플리케이션 계층(HTTP, FTP)까지 볼 수 있습니다.  
> 특정 세션 id를 가진 유저는 특정 서버에 라우팅되도록 라우팅 룰을 설정할 수 있습니다.

> **Q. 우리가 갖고 있는 LB가 노후화 되어서 7계층을 들여다 볼 수 있는 L7 장비가 아니고 L4 장비일 경우에는 어떻게 위와 같은 일을 할 수 있을까?**  
> A. IP를 이용하여 모듈러 연산을 하여 서버에 분배합니다.  
> (IP를 정수화 한다음 그 정수를 서버 대수대로 나누기를 하고 나머지로 라우팅)