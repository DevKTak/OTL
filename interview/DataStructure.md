# Data Structure
![img](https://github.com/f-lab-edu/hotel-java/assets/68748397/45b19457-1508-4bfe-af65-568b8c0e1ba6)

```
Q. Collection
A. 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
- Thread Safe한 컬렉션: Vector, HashTable, SynchronizedList, SynchronizedMap, SynchronizedSet, ConcurrentHashMap, ConcurrentQueue
- Thread Safe 하지 않은 컬렉션: ArrayList, HashSet, HashMap
```

```
Q. 해쉬맵에 대해서 설명해주세요. 
A. 어떤 키에 대해서 값을 저장하는 자료구조체이며 해쉬 함수를 이용하여 키-값을 저장합니다. 이때 해쉬 함수는 출력 값이 제한되어 있기 때문에 해쉬 충돌이 일어나는데 이를 해결하기 위한 제일 쉬운 방법은 각 해쉬 배열에 링크드 리스트를 연결한 체이닝 방식이 있습니다.
```

```
Q. Array vs LinkedList vs ArrayList
A. 
- Array: 연속된 메모리 공간에 존재
    - 장점: 순차적으로 데이터를 저장하기 때문에 index로 특정 요소 접근 가능
    - 단점: 정적 크기
    - 조회: O(1)
    - 삽입/삭제: O(N)
- LinkedList: 연속적인 메모리 위치에 저장되지 않는 선형 데이터 구조
    - 장점: 동적 크기, 삽입/삭제 용이
    - 단점: 각 요소마다 포인터의 메모리 공간이 필요함, 포인터를 찾아가는 시간이 필요하기 때문에 배열에 비해 접근속도가 느리다., 삽입/삭제를 하려면 첫번째 원소부터 다 확인해봐야한다.
    - 조회: O(N)
    - 삽입/삭제: O(1) 그러나 조회 후 삽입/삭제를 하기 때문에 결국 O(N)
- ArrayList: 연속된 메모리 공간에 존재
    - 장점: 동적 크기
    - 단점: 삽입/삭제 하는 경우에 복사가 일어나 성능 저하를 일으킬 수 있다.
    - 조회: O(1)
    - 삽입/삭제: O(N) (더하거나 뺄때마다 줄줄이 당겨지거나 밀려날 때 진행되는 연산, 추가적인 메모리 할당시 메모리 낭비)
```

```
Q. ArrayList 내부적으로 어떻게 구현되어 있을까? 배열로 구현되어있다면 크기가 꽉차면 일반 배열처럼 예외가 발생할텐데 어떻게 무한히 데이터를 받을 수 있을까?
A. 첫 element를 add 할 때 배열의 resize가 발생하고 배열 크기는 10으로 설정된다. 이후 가지고 있던 용량이 꽉 찼을때 현재 용량의 1.5배(기존의 크기 + 기존의 크기 / 2)를 늘린 새로운 배열에 기존 배열을 copy한다.
```

```
Q. List vs Set vs Map
A.
- List는 기본적으로 데이터들이 순서대로 저장되며 중복을 허용한다.
- Set은 순서가 보장되지 않고 데이터들의 중복을 허용하지 않는다.
- Map은 순서가 보장되지 않고 Key 값의 중복은 허용하지 않지만 Value 값의 중복은 허용된다.
```