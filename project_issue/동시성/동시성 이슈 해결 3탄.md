# 동시성 이슈 해결 3탄 - 현재 프로젝트에 가장 적합한 동시성 제어 방식? 적용해볼게요

## ✅ 동시성 제어 방식 선택
동시성 이슈 해결 2탄에서 공부한 내용을 토대로 사이드 프로젝트에 녹여내 볼건데요, 어떤 방식을 채택하여 동시성을 제어하는 것이 적절할까요?   
동시성 제어 방식을 채택하는 기준은 시스템의 특성, 회사의 특성, 요구사항 등을 고려하여 야합니다.

Application vs Mysql vs Redis
우선 실무에서는 두 대 이상의 서버를 사용할 확률이 크기 때문에 Application 레벨에서 처리하는 방식은 Pass 하겠습니다.   

Mysql vs Redis
다음으로 Redis 보다 성능은 좋지 않지만, DB 락을 트랜잭션이나 레코드 레벨에서 사용하여 일관성을 보장하는 Mysql과 인메모리 데이터베이스이기 때문에 높은 처리량과 낮은 지연 시간의 성능적 이점이 있는 Redis 중에 고민해봅니다.
현재 Redis를 사용중이지 않아서 별도의 구축비용과 인프라 관리비용이 발생하는 상황을 가정하여 Mysql을 택하고 추후에 고도화 하는 방식을 선택하였습니다.

Pessimistic Lock vs Optimistic Lock
마지막으로 데이터베이스를 이용하는 대표적인 방법 중에 실제로 데이터에 Lock을 걸어서 정합성을 맞추는 방법인 Pessimistic Lock(비관적 락)과 실제로 데이터베이스가 제공하는 Lock을 이용하지 않고 버전을 이용함으로써 정합성을 맞추는 방법인 Optimistic Lock 중에 고민하였습니다.   
두 방식 중 "동시에 수정하는 일이 빈번하게 일어나는가"를 기준으로 예약에 따른 재고 감소가 빈번하게 일어날 것으로 예상되며 읽는 쓰레드 보다 쓰기 작업이 비교적 더 많이 발생하는 상황을 가정하여 Pessimistic Lock을 채택하는 것으로 최종 결정 하였습니다.

## ✅ 멀티스레드 환경에서의 트랜잭션 문제

이 경우 트랜잭션은 여전히 다르지만 새로운 쓰레드에서 성공적으로 데이터를 조회했습니다. 하지만 격리수준이 낮으면 실제 서비스에서 Dirty Read를 비롯한 많은 문제가 발생할 수 있기 때문에 좋은 해결책이 아니라고 생각합니다.

BeforeEach가 아니라 sql.init.mode를 활용해 스프링 부트를 실행하는 시점에 데이터를 넣어줍니다. 트랜잭션 격리수준을 건들지 않고 문제를 해결할 수 있는 가장 좋은 방법이라고 생각합니다.


## ✅ 결론   
BeforeEach에서 insert한 데이터를 새롭게 생성한 쓰레드에서 조회하려고 하면 조회되지 않습니다.
그 이유는 BeforeEach부터 테스트코드가 끝날 때까지 데이터가 실제 DB에 커밋되지 않으며 트랜잭션이 다른 상태에서 커밋되지 않은 데이터를 조회하는게 불가능하기 때문입니다.
단편적으로 이 문제를 해결하기 위해 데이터를 조회하는 service의 trasaction isolation level을 Read Uncommited로 변경할 수도 있으나, 개인적으로 이러한 방법보다 테스트 데이터를 BeforeEach가 아니라 스프링 부트를 시작하는 시점에 넣는 방법으로 진행하는 걸 추천드립니다.