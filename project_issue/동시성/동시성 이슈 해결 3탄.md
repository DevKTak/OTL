# 동시성 이슈 해결 3탄 - 현재 프로젝트에 가장 적합한 동시성 제어 방식? 적용해볼게요
낙관적락 : 이것은 데이터베이스가 제공하는 락 기능을 사용하는 것이 아니라 JPA가 제공하는 버전 관리 기능을 사용한다.쉽게 이야기해서 애플리케이션이 제공하는 락이다.낙관적 락은 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다는 특징이 있다.


멀티스레드 환경에서 트랜잭션 문제

이 경우 트랜잭션은 여전히 다르지만 새로운 쓰레드에서 성공적으로 데이터를 조회했습니다. 하지만 격리수준이 낮으면 실제 서비스에서 Dirty Read를 비롯한 많은 문제가 발생할 수 있기 때문에 좋은 해결책이 아니라고 생각합니다.

BeforeEach가 아니라 sql.init.mode를 활용해 스프링 부트를 실행하는 시점에 데이터를 넣어줍니다. 트랜잭션 격리수준을 건들지 않고 문제를 해결할 수 있는 가장 좋은 방법이라고 생각합니다.


결론
BeforeEach에서 insert한 데이터를 새롭게 생성한 쓰레드에서 조회하려고 하면 조회되지 않습니다.
그 이유는 BeforeEach부터 테스트코드가 끝날 때까지 데이터가 실제 DB에 커밋되지 않으며 트랜잭션이 다른 상태에서 커밋되지 않은 데이터를 조회하는게 불가능하기 때문입니다.
단편적으로 이 문제를 해결하기 위해 데이터를 조회하는 service의 trasaction isolation level을 Read Uncommited로 변경할 수도 있으나, 개인적으로 이러한 방법보다 테스트 데이터를 BeforeEach가 아니라 스프링 부트를 시작하는 시점에 넣는 방법으로 진행하는 걸 추천드립니다.