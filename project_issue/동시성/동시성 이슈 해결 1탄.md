# 동시성 이슈 해결 1탄 - 동시성 이슈를 해결하기 위한 사전 지식? 쌓아볼게요
# 동시성이란?
> `공유 자원`에 대해 `동시에 여러 개의 프로세스 또는 쓰레드가 접근`하여 생기는 `경쟁 상황(Race Condition)`을 동시성 문제라고 합니다.

## ✅ 동기화(Synchronization)
여러 프로세스/스레드를 동시에 실행해도 `공유 데이터의 일관성`을 유지하는 것

## ✅ Race Condition(경쟁 조건)
`두 개 이상의 프로세스 혹은 스레드`가 공유 자원을 서로 사용하려고 `경합(Race)`하는 현상을 의미합니다.

## ✅ 상호 배제(Mutual Exclusion)
레이스 컨디션의 문제를 해결하고자 상호 배제 조건을 두어 동시에 공유 자원에 접근할 수 없도록 하여 **`한 자원에 한 스레드만 접근`** 할 수 있게 하는 것을 의미합니다.

## ✅ Critical Section(임계 영역)
공유 데이터의 `일관성을 보장하기 위해` `하나의 프로세스/스레드만 진입`해서 실행 가능한 영역

## ✅ 프로세스
CPU(프로세서)에 의해 실행되고 있는 프로그램이며 최소 1 개의 스레드가 존재합니다.   
JVM이 실행되어 컴파일러에 의해 변환된 바이트코드가 메모리 상에 올라갔을 때 "프로세스가 실행 중이다"라고 합니다.

### 멀티 프로세싱
두 개 이상의 프로세서(CPU)가 하나 이상의 작업(Task)을 동시에 처리하는 것입니다.(병렬처리)
프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업 속도가 느려질 수는 있지만 정지되는 문제는 발생하지 않습니다. (ex. 크롬 브라우저)

## ✅ 스레드
스레드는 프로세스 내에서 실행되는 작업 흐름의 단위입니다.   
메모리 영역(Code, Data, Heap)을 공유하기 때문에 메모리가 효율적이고, 같은 프로세스에 있는 스레들끼리 컨텍스트 스위칭 비용이 적으며 통신 비용도 절감됩니다.

### 멀티 스레드
하나의 프로세스가 동시에 여러 개의 스레드를 수행할 수 있도록 해주는 것입니다.   
스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받습니다. (ex. 익스플로러 브라우저)

## ✅ Thread Safe
여러 스레드가 작동하는 환경에서도 동시성 이슈 없이 동작하는 것을 스레드 안전하다고 말합니다.

## ✅ Lock
### Exclusive Lock(배타적 잠금)
- `쓰기 잠금(Write Lock)`
- 어떤 트랜잭션에서 데이터를 변경하고자 할 때 해당 트랜잭션이 완료될 때까지 해당 테이블 혹은 레코드(row)에 다른 트랜잭션에서 읽거나 쓰지 못하게 락을 걸고 트랜잭션을 진행시키는 것입니다.

### Shared Lock(공유 잠금)
- `읽기 잠금(Read Lock)`
- 리소스를 다른 사용자가 동시에 읽을 수 있게 하되 변경은 불가하게 하는 것입니다.
- Shared Lock을 사용하는 쿼리끼리는 같은 Row에 접근이 가능합니다.

## ✅ [데드락(Deadlock)]   
(https://github.com/DevKTak/OTL/blob/main/CS/OS/%EB%8D%B0%EB%93%9C%EB%9D%BD.md)

</br>

# 동시성 이슈 해결 방법 (동시성 제어 방식)
## ✅ **동시성 이슈 예시**
- 우리가 예상한 상황
<img width="1576" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/06f7811b-7d54-4932-bae6-27458c242d06">

- 실제 Race Condition이 일어날 때 상황
<img width="1580" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/4ca6b7cf-1709-47cf-a18a-4bd8ef5c61fd">

## ✅ **1. Application 레벨에서 해결하는 방법**
### 1. synchronized 키워드
- **한 번에 하나의 스레드만 특정 블록 또는 메서드에 접근할 수 있도록 동기화 처리하는 방법입니다.**
- Exclusive Lock(배타적 잠금)
- **`하나의 프로세스 안에서만 보장이 됩니다.` 서버가 2대 이상일 경우 데이터에 여러대에서 동시에 접근 할 수 있기 때문에 Race Condition이 발생할 수 있습니다. 실제 운영중인 서비스는 대부분 2대 이상의 서버를 사용하기 때문에 Synchronized는 거의 사용되지 않습니다.**

### 2. volatile 키워드
- Java 변수를 Main Memory에 저장하겠다라는 것을 명시하는 것입니다.
- 멀티 쓰레드 환경에서 모든 쓰레드들이 CPU 메인 메모리의 동일한 변수를 공유할 수 있게됩니다.
- 즉, 각 CPU 의 쓰레드가 가진 CPU Cache 에다 캐싱을 하는것이 아니라, **모든 쓰레드가 공유하는 메인 메모리에서 읽고 쓰는 연산을 진행하도록 하는 방법**입니다.

### 3. Atomic 변수
원자성을 보장해주는 Atomic 클래스의 AtomicInteger, AtomicLong, AtomicBoolean 와 같은 Atomic 변수를 사용해서 동시성을 해결하는 방법입니다.
- Atomic 클래스는 `CAS(compare-and-swap)알고리즘`을 활용하여 구현되어있으며 `CAS 알고리즘`은 **쓰레드가 가지고 있던 원래 값이 현재의 값과 같은 지 비교하고, 같으면 그냥 사용하고 다르면 현재의 값을 받아옵니다.**

### 4. 불변 객체(Immutable Instance)
내부적인 상태가 변하지 않으니 여러 스레드에서 동시에 참조해도 동시성 이슈가 발생하지 않습니다. 즉, **불변 객체는 언제나 스레드 안전(Thread-safe)** 합니다.   
불변 객체는 생성자로 모든 상태 값을 생성할 때 세팅하고, 객체의 상태를 변화시킬 수 있는 부분을 모두 제거해야 합니다.   

**[불변 객체로 만드는 방법]**
- Setter를 만들지 않는다.
- 내부 상태가 변하지 않도록 모든 변수를 final로 선언한다.
- 함수형 프로그래밍을 사용한다.

### synchronized 키워드 vs Atomic 변수
synchronized 키워드는 블럭 전체를 블로킹(Blocking)하여 다른 스레드는 아무런 작업을 하지 못하고 기다리는 상황이 발생 할 수 있어서 낭비가 심합니다.   
Atomic은 Non-Blocking이 가능하므로 성능상 이점이 있습니다.

## ✅ **2. Mysql을 활용하는 방법 (Database Lock)**
### 1. Pessimistic Lock(비관적 락)
- `실제로 데이터에 Lock을 걸어서 정합성`을 맞추는 방법
- Exclusive Lock(배타적 잠금)을 걸게되면 다른 트랜잭션에서는 Lock이 해제되기 전에 데이터를 가져갈 수 없게 됩니다.
- 뮤텍스나 세마포어와 유사한 동기화 처리 기법을 사용합니다.   
  
    ### 장점
    - 동시성 충돌이 잦을 것으로 예상되어 동시성을 강력하게 지켜야할 때 사용합니다.
    - 충돌이 빈번하게 일어난다면, 롤백의 횟수를 줄일 수 있기 때문에 Optimistic Lock 보다는 성능이 좋을 수 있는 가장 강력한 데이터 정합성 보장 방법입니다.

    ### 단점
    - 데이터 자체에 Lock을 걸기 때문에 속도가 상대적으로 느린 편입니다.
    - 서로 자원이 필요한 경우, 락이 걸려있으므로 데드락에 걸릴 수 있습니다.

<img width="936" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/448aea2e-1fd9-4118-a9b2-204ea53d9ece">

- Server 1이 락을 걸고 데이터를 가져가게 되면 Server 2 ~ 5는 Server 1이 락을 해제 하기전까지는 데이터를 가져갈 수 없습니다.

<img width="1580" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/6a5c2b5d-d154-4c62-bdd2-6e99d94a5dcc">

### 2. Optimistic Lock(낙관적 락)
- 실제로 데이터베이스가 제공하는 Lock을 이용하지 않고 `버전을 이용함으로써 정합성`을 맞추는 방법입니다.(애플리케이션이 제공하는 락)
- 먼저 데이터를 읽은 후에 update를 수행할 때 현재 내가 읽은 버젼이 맞는지 확인하며 업데이트 합니다.
- 내가 읽은 버전에서 수정사항이 생겼을 경우에는 application에서 다시 읽은 후에 작업을 수행하는 `롤백` 작업을 수행해야 합니다.

    ### 장점
    - 충돌이 자주 일어나지 않는다는 가정하에, 별도의 Lock을 걸지 않으므로 Pessimistic Lock 보다는 성능적 이점을 가질 수 있습니다.

    ### 단점
    - 업데이트가 실패했을 시, 재시도 로직을 개발자가 직접 작성해 주어야 합니다.
    - 충돌이 빈번하게 일어난다면, Roll Back 처리를 해주어야 하기 때문에 Pessimistic Lock이 더 성능이 좋을 수 있습니다.

<img width="857" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/108b1e05-e689-4144-9ebd-0b544068ad66">

  1. Sever 1이 update 하면서 `version 2로 업데이트` 함
  2. 1번 과정 이후에 Server 2가 동일한 update 쿼리를 수행하려할 때 `where의 version = 1` 이 false 이기 때문에 update 실패
  3. `내가 읽은 버전에서 수정사항이 생겼을 경우`에는 `application에서 다시 읽은 후에 작업을 수행해야 하는 로직`을 넣어줘야 합니다.

<img width="1851" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/22cfae92-7d7d-42bb-baf4-ff2e446adf6d">

### 3. Named Lock(네임드 락)
- 이름을 가진 `Metadata Locking` 입니다.
- 이름을 가진 Lock을 획득한 후 해제할 때까지 다른 세션은 이 Lock을 획득할 수 없도록 합니다.
- 주의할점으로는 `Transaction이 종료될 때 Lock이 자동으로 해제되지 않기 때문에` `별도의 명령어로 해제를 수행해주거나 선점시간이 끝나야 해제`됩니다.
- Pessimistic Lock(비관적 락)과 유사한데 차이점은 `Pessimistic Lock(비관적 락)은 row 나 테이블 단위로 Lock`을 걸지만 `Named Lock(네임드 락)은 Metadata에 Locking`을 하는 방식입니다.
- Mysql에서는 getLock()을 통해 획득하고 releaseLock()으로 해제할 수 있습니다.

<img width="1739" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/471c65b1-7844-4104-9601-3eaa8fb072ff">
  
- 락을 Stock에 직접 걸지 않고 별도의 공간에 락을 겁니다.
- session-1 이 1이라는 이름으로 Lock을 건다면, session 1이 1을 해제한 후에 Lock을 얻을 수 있습니다.

### 참고   
> - https://dev.mysql.com/doc/refman/8.0/en/
> - https://dev.mysql.com/doc/refman/8.0/en/locking-functions.html
> - https://dev.mysql.com/doc/refman/8.0/en/metadata-locking.html


## ✅ 3. **Redis를 활용하여 분산락을 구현하는 방법 (대표적인 라이브러리 2가지)**
> **Redis:** key-value 구조의 비정형 데이터를 저장하고 관리하기 위한 오픈 소스 기반의 비 관계형 인메모리 DBMS입니다. Redis의 다양한 특징 중에서도 Single Threaded 한 특징 즉, 한 번에 하나의 명령만 처리할 수 있는 특징 때문에 동시성 문제를 해결하는데 많이 사용됩니다.
> 
### 1. Lettuce
- **`setnx`** 명령어를 활용하여 분산락 구현: key와 value를 set 할 때, **기존에 값이 없을 때만 set 하는 방법**
- **`spin lock 방식`**: 락을 획득하려는 스레드가 락을 사용할 수 있는지 반복적으로 확인하면서 락 획득을 시도하는 방식, 락을 획득할 때까지 재시도하는 로직을 작성 해줘야 합니다.
- Mysql의 `Named Lock`과 마찬가지로 로직 실행 전, 후로 락 획득/해제를 해줘야 합니다.
- Mysql의 `Named Lock`과 거의 비슷한데 다른점으로는 Redis를 이용한다는 점과 세션 관리에 신경을 안써도 된다는 점입니다.

<img width="1008" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/9e29b65d-3276-4cf3-bb29-d6d39135e07e">

### 2. Redisson
- **`pub-sub`** 기반으로 Lock 구현: `채널`을 하나 만들고 락을 점유중인 스레드가 락을 해제했음을 **대기중인 스레드에게 해제를 알려주면** 안내를 받은 스레드가 락 획득 시도를 하는 방식, 대부분의 경우에 Lettuce와는 다르게 별도의 Retry 로직을 작성하지 않아도 됩니다.
- Redisson은 락 관련 클래스들을 라이브러리에서 제공해주므로 별도의 Repository를 작성하지 않아도 됩니다.

<img width="1839" alt="image" src="https://github.com/DevKTak/DevKTak/assets/68748397/a45c5ca3-8532-40ce-892e-c2c3f04cb969">

## ✅ Lettuce와 Redisson 라이브러리 비교
### Lecttuce
    - 장점: 
        1. 구현이 간단하다.
        2. Spring Data Redis를 이용하면 Lettuce가 기본이기 때문에 별도의 라이브러리를 사용하지 않아도 된다.
    - 단점: 
        1. Spin Lock 방식이기 때문에 동시에 많은 스레드가 lock 획득 대기 상태라면 Redis에 부하가 갈 수 있다. 그렇기 때문에 Thread.sleep()을 통해 락 획득 재시도 간에 텀을 줘야한다.

### Redisson
    - 장점: 
        1. 락 획득 재시도를 기본으로 제공한다.
        2. pub-sub 방식이기 때문에 Lettuce는 계속 락 획득을 시도하는 반면에 Redisson은 락 해제가 되었을 때, 한번 혹은 몇번만 시도를 하기때문에 Redis에 부하를 줄여주게 됩니다.
    - 단점:
        1. Spring Data Redis의 기본 라이브러리는 Rettuce이기 때문에 별도의 라이브러리를 사용해야하고, lock 관련 클래스들을 라이브러리 차원에서 제공해주기 때문에 사용법을 공부해야 한다.

### 결론
> 재시도가 필요하지 않은 Lock은 **`Lettuce`** 활용   
> 재시도가 필요한 경우에는 **`Reddisson`** 을 활용

## ✅ 비관적락(Pessimistic Lock) vs 낙관적락(Optimistic Lock)
낙관 락과 비관 락은 동시성 제어에 있어서 사용되는 방식 중 하나입니다.
낙관적락과 비관적락을 사용하는 기준은 "동시에 수정을 하는일이 빈번하게 일어나는가 ?" 입니다.
그렇기때문에 동일한 사례에서도 동시에 수정을 하는일이 적다면 낙관적락을, 동시에 수정하는 상황이 빈번하게 일어난다면 비관적락을 사용한다고 이해하시면 좋을 것 같습니다.
예를들어 1000명의 사용자가 동시에 A 라는 상품을 구매할 때 "충돌이 빈번하게 일어난다" 라고 생각할 수 있을 것 같습니다.
반대로 1000명의 사용자가 A 라는 상품을 구매하지만 구매시간이 각자 다를 때 (예를들어 사용자 1은 1시에, 사용자 2는 1시 1분에 사용자 3은 1시 2분에...) "충돌이 비교적 적게 일어난다" 라고 생각할 수 있을 것 같습니다.

낙관적락의 구현은 JPA 을 사용한다면 크게 어렵지 않게 구현할 수 있기때문에 실무에서도 사용됩니다.

충돌이 빈번하게 일어나는 상황에서 낙관적락을 사용하게 된다면 모든 요청이 완료될때까지 재시도를 수행할 것 입니다.
예를들어 1000 개의 동시수정이 발생한다면 1000 개의 요청이 모두 완료될때까지 재시도를 수행할 것 입니다.
구현마다 다르겠지만 성공할때까지 시도한다고 가정했을 때 데이터베이스에 굉장히 많은 요청을 보내게 될 것입니다.
반면에 비관적락을 사용한다면 lock 을 걸고 수행하기때문에 이후의 요청들은 업데이트가 완료될때까지 기다렸다가 순차적으로 진행하게 됩니다.
이러한 관점에서 봤을 때 충돌가능성이 많다면 비관적락이 더 좋은선택이 될 수 있습니다.

비관적 락은 공유 자원을 사용할 때 다른 쓰레드와 충돌이 발생할 가능성이 높다고 가정하고 그에 따라 **`공유 자원에 대한 락을 걸어` 다른 쓰레드에 대한 접근을 막는 방식**입니다. 따라서, 충돌이 빈번하게 일어나는 환경에서 사용하게 되면 효과적일 수 있습니다.

반면에, **낙관적 락은 충돌이 발생하지 않을 것으로 가정하고 그에 따라 공유 자원에 대한 `락을 걸지 않고 접근`할 수 있습니다.** 만약, 다른 쓰레드가 이미 락을 걸어놓은 경우에는 대기하다가 락이 풀리면 자원에 대한 접근을 시도합니다.

실무에서 구체적인 예시를 들면, 낙관적 락은 일반적으로 읽기 비율이 높은 경우에 사용할 수 있습니다. 예를 들어, **`게시글을 읽는 쓰레드가 다수 존재하고, 쓰기 작업은 비교적 드물게 발생하는 경우에는 낙관적 락`** 이 효과적일 수 있습니다. 반면에, **`쓰기 작업이 빈번하게 발생하는 경우에는 비관적 락`** 을 사용하는 것이 좋습니다.

또한, 실제로 낙관적 락을 구현해서 사용하는 경우도 있습니다. 낙관적 락의 경우, 충돌이 발생하지 않을 것으로 가정하기 때문에 락을 걸지 않다는 것 자체가 성능상 이점을 가질 수 있습니다. 따라서, 낙관적 락을 구현하고 사용하는 것이 효과적일 수 있습니다.

마지막으로, 충돌이 빈번하게 일어난다면 비관적 락이 더 적합한 이유는 `충돌이 발생할 가능성이 높다는 것을 가정하고 적극적으로 락을 거는 방식이기 때문입니다.` 따라서, `충돌이 발생할 가능성이 높은 경우에는 비관적 락`을 사용하는 것이 더 효과적입니다.

## ✅ Mysql과 Redis 비교
### Mysql
    - 장점: 
        1. 이미 Mysql을 사용하고 있다면 별도의 비용없이 사용 가능하다.
        2. 어느 정도의 트래픽까지는 문제없이 활용이 가능하다.
    - 단점:
        1. Redis 보다는 성능이 좋지 않다.

### Redis
    - 장점: 
        1. Mysql 보다 성능이 좋다.
    - 단점:
        1. 활용중인 Redis가 없다면 별도의 구축비용과 인프라 관리비용이 발생한다.

### 그래서 동시성 제어 시 어떤 방법을 채택해야 할까?
> 일반적으로 레디스는 **`인메모리 데이터베이스이기 때문에 높은 처리량과 낮은 지연 시간`** 을 제공합니다. 따라서 **`많은 동시 요청을 처리해야 하는 시스템이라면`**, 레디스를 사용하여 동시성 제어를 하는 것이 더 효율적일 수 있습니다.   
> 
> 반면에 DB 락은 데이터의 **`consistency(일관성)`** 를 보장하면서 동시에 데이터 접근을 제어할 수 있는 방법입니다. DB 락은 일반적으로 트랜잭션이나 레코드 레벨에서 사용되며, **`데이터베이스에서 처리해야 할 복잡한 로직`** 이 있는 경우에 적합합니다.
> 
> 따라서, 동시성 제어 방법은 시스템의 특성, 회사의 특성, 요구사항에 따라 다르게 결정되어야 하며, 단순한 상황에 따라 “레디스를 사용하는 것이 제일 좋은 방법”이거나 “DB 락을 사용하는 것이 더 좋은 경우”로 일반화할 수는 없습니다.  
동시성 제어 방법을 결정할 때는 시스템의 특성, 처리량, 지연 시간 요구사항, 데이터 일관성 등을 고려하여 적절한 방법을 선택해야 합니다.

## ✅ 상호 배제(Mutual exclusion)를 위한 동기화 처리 기법 (락 매카니즘)
### 1. 스핀 락(Spin Lock)
락을 가질 수 있을 때 까지 `반복해서 시도`   
단점: 기다리는 동안 CPU를 낭비

### 2. 뮤텍스(Mutex)
락을 가질 수 있을 때 까지 `휴식`하는 기법
- 예) 화장실이 하나 뿐이 없는 식당

### 3. 세마포어(Semaphore)
**`Signal Mechanism.`** 현재 공유 자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법
 - 예) 화장실이 여러개가 있고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있는 레스토랑
  
### 4. 모니터(Monitor)
Mutual Exclusion(상호배제)을 보장, 조건에 따라 스레드가 대기(Wating) 상태로 전환 기능
**`뮤텍스와 세마포어를 추상화한 개념`**

## ✅ 그럼 뮤텍스가 스핀락보다 항상 좋은걸까?
`멀티코어` 환경이고, **`Critical Section(임계 영역)`에서의 작업이 `컨텍스트 스위칭`보다 더 빨리 끝난다면** `스핀락`이 `뮤텍스`보다 더 이점이 있습니다.   
- 여기서 말하는 컨텍스트 스위칭은 뮤텍스에서 락을 가질 수 있을 때 까지 `휴식`하다가 깨는 과정입니다.   
- `싱글 코어`에서는 결국 컨텍스트 스위칭이 필요하기 때문에 스핀락의 이점이 전혀 없습니다.

### [참고]
> - [뮤텍스(Mutex)와 세마포어(Semaphore) 차이](https://worthpreading.tistory.com/90)
> - [스핀락(Spin Lock), 뮤텍스(Mutex), 세마포(Semaphore) 각각의 특징과 차이](https://www.youtube.com/watch?v=gTkvX2Awj6g)
> - [모니터(Monitor)](https://www.youtube.com/watch?v=Dms1oBmRAlo)
