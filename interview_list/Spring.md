# Spring
<!-- > **Q. OOP 원칙**   
> A.   
> - **SRP(Single Responsibility Principle): `단일 책임 원칙`**   
>   - 클래스는 단 하나의 책임을 가져야 한다.
> - **OCP(Open-Closed Priciple): `개방-폐쇄 원칙`**   
>   - 확장에는 열려있어야하고 변경에는 닫혀 있어야 한다.
> - **LSP(Liskov Substitution Principle): `리스코프 치환 원칙`**
>      - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.   
> - **ISP(Interface Segregation Principle) : `인터페이스 분리 원칙`**   
>      - 클라이언트는 사용하지 않는 인터페이스에 강제로 의존해서는 안된다.
(바꿔 말하면, 하나의 큰 인터페이스보다는 여러개의 작은 인터페이스를 구현하는 것이 낫다라고도 할 수 있습니다)
> - **DIP(Dependency Inversion Principle) : `의존 관계 역전 원칙`**
>      - 객체는 저수준 모듈보다 고수준 모듈에 의존해야 한다.   
>          - 고수준 모듈: 인터페이스와 같은 객체의 형태나 추상적 개념
>          - 저수준 모듈: 구현된 객체
>      - 객체는 객체보다 인터페이스에 의존해야한다.
>      - 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다. -->

```
Q. OOP 원칙
A.   
- SRP(Single Responsibility Principle): 단일 책임 원칙   
    - 클래스는 단 하나의 책임을 가져야 한다.
- OCP(Open-Closed Priciple): 개방-폐쇄 원칙   
    - 확장에는 열려있어야하고 변경에는 닫혀 있어야 한다.
- LSP(Liskov Substitution Principle): 리스코프 치환 원칙
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.   
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙   
    - 클라이언트는 사용하지 않는 인터페이스에 강제로 의존해서는 안된다.
    - (바꿔 말하면, 하나의 큰 인터페이스보다는 여러개의 작은 인터페이스를 구현하는 것이 낫다라고도 할 수 있습니다)
- DIP(Dependency Inversion Principle) : 의존 관계 역전 원칙
    - 객체는 저수준 모듈보다 고수준 모듈에 의존해야 한다.   
        - 고수준 모듈: 인터페이스와 같은 객체의 형태나 추상적 개념
        - 저수준 모듈: 구현된 객체
    - 객체는 객체보다 인터페이스에 의존해야한다.
    - 즉, 가급적 객체의 상속은 인터페이스를 통해 이루어져야 한다는 의미로 해석할 수 있다.
```

```
Q. abstract와 Interface의 차이는?
A.
- abstract: 부모의 기능을 자식에서 확장시켜나가고 싶을때 (abstract는 다중 상속이 안된다. 상황에 맞게 활용하자!)
- interface: 해당 클래스가 가진 함수의 구현을 강제하고 싶을때 (자바 8부터 default 키워드를 이용해서 일반 메소드의 구현 가능)
```

```
Q. OOP에 대해 설명해주세요
A. 역할과 책임을 가진 객체들이 메시지를 주고 받으면서 협력하는 것
- 추상화: 핵심적인 개념 또는 기능을 간추려 내는 것, 추상적인 주체가 바로 클래스(class)
- 상속: 부모 클래스의 속성과 행위들을 물려받는 것
- 캡슐화: 속성과 행위들을 관련있는 것끼리 묶고 정보를 은닉하는 것, 세부 구현을 숨기는 목적은 응집도를 높이고 다른 클래스와의 결합도를 낮추는 데 있다.
- 다형성: 객체지향의 꽃, 상속을 받아서 재정의(override) 하는 것
```

> ### **Q. Dispatcher-Servlet**
> A. HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러


> ### **Q. Filter, Interceptor, AOP 차이점**
> A.   
> **Filter:** Dispatcher Servlet에 요청이 전달되기 전/후에 필터링하는 것, `서블릿 컨테이너` 에 의해 관리됨
> - 용도: Spring과 분리되어야 하는 기능,
> 공통된 보안(XSS 방어) 및 인증/인가 관련 작업, 모든 요청에 대한 로깅 또는 감사
> 
> **Interceptor:** Dispatcher Servlet이 컨트롤러를 호출하기 전/후에 가로채는 것, `스프링 컨테이너` 에 의해 관리됨
> - 용도: 세부적인 보안 및 인증/인가 공통작업, API 호출에 대한 로깅 또는 감사   
>
> **AOP**: OOP를 보완하기 위해 나옴, 횡단 관심사를 처리함   
>
> <img src="https://github.com/f-lab-edu/hotel-java/assets/68748397/23b89718-b229-4f61-9bce-f902ce2b21ca" width="85%">
> <img width="85%" alt="image" src="https://github.com/f-lab-edu/hotel-java/assets/68748397/08c3673d-3f80-4477-9c58-5bab54bb7f48">

> ### **Q. 스프링 3대 요소**
> A.   
> DI(Dependency Injection): 객체를 직접 생성하는게 아니라 외부에서 생성한 후 주입시켜주는 방식입니다. 객체간의 결합도(coupling)가 낮아지고 유연성이 높아집니다.   
> 
> IoC(Inversion of Control): 객체의 생성과 생명주기 관리를 개발자가 아닌 스프링 컨테이너가 담당하여 제어합니다. 그로인해 DI, AOP 등이 가능하게 됩니다.   
> 
> AOP: 관점 지향 프로그래밍이라고도 불리며, 핵심 로직과 공통 기능을 분리하여 모듈화하는 프로그래밍 기법입니다. AOP가 적용된 사례 => 예) @Transactional

> ### **Q. DI 장점중 모듈간의 결합도가 왜 낮다고 생각하는지, 뭐때문에 낮다고 하는지?**
> A. 객체를 직접 생성하는것이 아닌 외부에서 생성해서 주입해주기 때문에 의존성이 낮아지고 의존성이 낮아지면 한 클래스가 바뀔 때 다른 클래스가 영향을 받지 않기 때문에 결합도가 낮아진다.

> ### **Q. 의존성 주입 방법 3가지**
> A.
> 1. 수정자 주입
>       - 단점: setter메서드를 public으로 열어두어야 하기 때문에 어디서든 변경이 가능하다., 신뢰성
> 2. 필드 주입
>       - 단점: 프레임워크에 의존적이다. null이 만들어질 가능성이 있다. 테스트가 어렵다.
> 3. 생성자 주입
>       - 장점
>           1. 순환 참조 방지(애플리케이션 실행 시점에 오류 체크 가능, 필드, 수정자 주입은 빈이 실행된 후에 참조하기 때문에 런타임 시점에 에러가 날 가능성이 있다.)   
>           2. 불변성(Immutability), final로 선언 가능
>           3. 테스트에 용이하다. 서비스 생성하면서 파라미터로 레파지토리를 넘기면 원하는 구체 레파지토리를 테스트할 수 있음

> ### **Q. 디자인 패턴**
> A. 반복적으로 발생하는 문제에 대한 해결책을 제공하고, 유지보수성과 재사용성을 높이는 목적을 가지고 있습니다.   
> **1. `Singleton` 패턴: 한 클래스에 대해 하나의 객체만 존재하도록 하는 것**    
> **2. `Proxy` 패턴: 실제 기능을 수행하는 객체 대신 가상의 객체를 사용해 로직의 흐름을 제어**   
> **3. `Factory Method` 패턴: 객체 생성을 직접하지 않고, 하위 클래스가 어떤 객체를 생성할지 결정하도록 위임하는 디자인 패턴입니다. 즉, 오버라이드된 메서드가 객체를 반환하는 패턴, 템플릿 메소드 패턴을 활용**  
> **4. `Template Method` 패턴: 상속을 통해 부모클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법 ex) jdbcTemplate**   
> **5. `Stratege` 패턴: 옵션들마다의 행동들을 모듈화하여 상호 교환이 가능하게 하는 것(DI를 사용할 때 쓰는 패턴)**   
> **6. `Adapter` 패턴: 인터페이스가 서로 다른 객체들이 같은 형식 아래 작동할 수 있도록 하는 역할을 함**   
> **7. `decorator` 패턴: 객체가 생성자 변수로 다른 객체 안에 들어감으로써 그 실행하는 메소드의 행동이 추가되도록 하는것**   
> **8. `facade(퍼사드)` 패턴: 복잡한 서브 클래스들의 공통적인 기능을 정의하는 상위 수준의 인터페이스를 제공 하는 패턴**
>
> <img width="880" alt="image" src="https://github.com/f-lab-edu/hotel-java/assets/68748397/7fb33beb-1652-4925-a7d7-94a332e0e9f2">
**참고**   
[팩토리 메소드 패턴과 템플릿 메소드 패턴](https://kimjye.tistory.com/entry/%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%8131-1%EC%9E%A5)

> ### **Q. Java 싱글톤과 Spring 싱글톤의 차이**
> A. 싱글톤 패턴이란 한 클래스에 대해 하나의 객체만 존재하도록 하는 것
> 1. 자바 싱글톤은 클래스로더에 의해 구현되고, 스프링 싱글톤은 스프링 컨테이너에 의해 구현된다.
> 2. 자바 싱글톤의 scope는 코드 전체이고, 스프링 싱글톤의 scope는 해당 컨테이너 내부이다.
> 3. 스프링에 의해 구현되는 싱글톤패턴은 Thread safety를 자동으로 보장한다. 자바로 구현하는 싱글톤패턴은 개발자의 로직에 따라 thread safety를 보장할 수도 보장하지 않을 수도 있다. (@Bean이 정의되면 스프링 컨테이너는 그 클래스에 대해서 딱 한 개의 인스턴스를 만들고 항상 단일 공유 인스턴스를 리턴하기 때문)

> ### **Q. Spring Bean 생명주기**
> A. 2) 스프링 빈의 이벤트 라이프 사이클
> 스프링 내부에서는 스프링의 라이프 사이클과 관련하여 이벤트가 있는데 > 순서는 다음과 같다.   
> 
> 스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백(EVENT) → 앱 본연의 동작 수행 → 소멸전 콜백(EVENT) → 스프링 종료
>    
> 즉, 스프링 컨테이너가 가동되고 본격적으로 앱이 동작하기 전에 한 번, 스프링이 종료되기 전에 한 번 특정한 동작을 수행할 수 있는 이벤트가 존재한다.
>
>이러한 이벤트에서 우리는 초기화 콜백을 이용하여 테스트로 사용할 데이터를 앱의 사전 동작 전에 미리 저장한다던지, 또는 소명전 콜백을 이용하여 사고에 가깝게 스프링이 종료되는 상황에서 데이터를 백업하는 등의 동작을 수행할 수 있다.